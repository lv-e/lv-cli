"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const helpers_1 = require("../helpers/helpers");
const fs_1 = require("fs");
const path_1 = require("path");
const shelljs_1 = __importDefault(require("shelljs"));
const astyle_1 = __importDefault(require("astyle"));
const encoder_templates_1 = require("../helpers/encoder_templates");
const chalk = require("chalk");
const helpText = `
'encode' will receive a path to the project structure generated by 'scan'
 and encode files by its extension.
 the output will be a .h strip.`;
let vflag = false;
let sceneID = 1;
let outputDir;
let encoders = [];
function encode(input, output, mode) {
    return __awaiter(this, void 0, void 0, function* () {
        if (mode == "help")
            helpers_1.log(true, helpText);
        else {
            outputDir = output;
            vflag = mode == "verbose" ? true : false;
            helpers_1.log(vflag, chalk.green("[command] ") + chalk.blue("encode"));
            const jsonString = fs_1.readFileSync(input, "utf8");
            const data = JSON.parse(jsonString);
            encodeProject(data.project_file);
            let promises = yield data.scenes.map((scene) => __awaiter(this, void 0, void 0, function* () {
                return yield encodeScene(scene);
            }));
            let encodedScenes = yield Promise.all(promises);
            encodeMainFiles(encodedScenes);
        }
    });
}
exports.encode = encode;
function encodeMainFiles(encodedScenes) {
    helpers_1.log(vflag, chalk.cyan("generating main.c file"));
    let includes = encodedScenes.map(s => s.main_h).join("\n");
    let mainCode = helpers_1.replaceAll(encoder_templates_1.template_main_c, "{{scene_includes}}", includes);
    let mainFilePath = path_1.join(outputDir, "source", "main.c");
    fs_1.writeFileSync(mainFilePath, mainCode);
    helpers_1.log(vflag, "done! main.c can be found at: " + mainFilePath);
}
function updateModules() {
    encoders.forEach(encoder => {
        if (!shelljs_1.default.which(encoder.cli_command)) {
            helpers_1.log(vflag, "updating encoder under npm module named " + encoder.npm_module);
            shelljs_1.default.exec("npm update -g " + encoder.npm_module);
        }
    });
}
function encodeProject(file) {
    const jsonString = fs_1.readFileSync(file.path, "utf8");
    const project = JSON.parse(jsonString);
    encoders = project.header.encoders;
    helpers_1.log(vflag, "updating node modules...");
    updateModules();
    encoders.forEach(encoder => {
        if (encoder.extension == file.extension) {
            const outputFile = path_1.join(outputDir, "h-stripes", file.name + ".h-stripe");
            helpers_1.log(vflag, chalk.cyan("encoding game project: ") + file.name + " with " + encoder.npm_module);
            shelljs_1.default.exec(encoder.cli_command + " -i " + file.path + " -o " + outputFile);
        }
    });
}
function encodeScene(scene) {
    return __awaiter(this, void 0, void 0, function* () {
        helpers_1.log(vflag, chalk.cyan("encoding: ") + chalk.cyanBright(scene.name));
        encodeDir(scene, scene);
        const response = yield mergeEncoded(scene);
        const sceneSourceDir = path_1.join(outputDir, "source");
        let hppPath = path_1.join(sceneSourceDir, scene.name + ".h");
        let cppPath = path_1.join(sceneSourceDir, scene.name + ".c");
        helpers_1.createDirs(hppPath);
        helpers_1.createDirs(cppPath);
        fs_1.writeFileSync(hppPath, response.hpp);
        fs_1.writeFileSync(cppPath, response.cpp);
        return response.encodedScene;
    });
}
function encodeDir(dir, scene) {
    dir.directories.forEach(dir => encodeDir(dir, scene));
    dir.files.forEach(file => encodeFile(file, scene));
}
function encodeFile(file, scene) {
    encoders.forEach(encoder => {
        if (encoder.extension == file.extension) {
            helpers_1.log(vflag, "encoding file: " + file.name + " with " + encoder.npm_module);
            const outputFile = path_1.join(outputDir, scene.name, "h-stripes", file.name + ".h-stripe");
            shelljs_1.default.exec(encoder.cli_command + " -i " + file.path + " -o " + outputFile);
        }
    });
}
function mergeEncoded(scene) {
    return __awaiter(this, void 0, void 0, function* () {
        const sceneDir = path_1.join(outputDir, scene.name, "h-stripes");
        helpers_1.log(vflag, "reducing encoded scene files under dir " + sceneDir);
        const files = fs_1.readdirSync(sceneDir);
        let reduced = {
            main_h: "",
            declarations: "",
            on_awake: "",
            on_enter: "",
            on_frame: "",
            on_exit: ""
        };
        reduced.main_h = applySceneReplaces(encoder_templates_1.template_scene_include, scene);
        files.forEach(file => {
            const filepath = path_1.join(sceneDir, file);
            const jsonString = fs_1.readFileSync(filepath, "utf8");
            const data = JSON.parse(jsonString);
            reduced.declarations += helpers_1.removeBlankLines("\n" + (data.declarations || ""));
            reduced.on_awake += helpers_1.removeBlankLines("\n" + (data.on_awake || ""));
            reduced.on_enter += helpers_1.removeBlankLines("\n" + (data.on_enter || ""));
            reduced.on_frame += helpers_1.removeBlankLines("\n" + (data.on_frame || ""));
            reduced.on_exit += helpers_1.removeBlankLines("\n" + (data.on_exit || ""));
        });
        function applyReplaces(subject) {
            let mutable = applySceneReplaces(subject, scene);
            mutable = helpers_1.replaceAll(mutable, "{{declarations}}", reduced.declarations);
            mutable = helpers_1.replaceAll(mutable, "{{on_awake}}", reduced.on_awake);
            mutable = helpers_1.replaceAll(mutable, "{{on_enter}}", reduced.on_enter);
            mutable = helpers_1.replaceAll(mutable, "{{on_frame}}", reduced.on_frame);
            mutable = helpers_1.replaceAll(mutable, "{{on_exit}}", reduced.on_exit);
            return mutable;
        }
        let sceneCPPFile = yield astyle_1.default.format(applyReplaces(encoder_templates_1.template_scene_cpp));
        let sceneHPPFile = yield astyle_1.default.format(applyReplaces(encoder_templates_1.template_scene_hpp));
        return { hpp: sceneHPPFile, cpp: sceneCPPFile, encodedScene: reduced };
    });
}
function applySceneReplaces(subject, scene) {
    let mutable = subject;
    mutable = helpers_1.replaceAll(mutable, "{{scene_name}}", scene.name);
    mutable = helpers_1.replaceAll(mutable, "{{uppercased_scene_name}}", scene.name.toUpperCase());
    mutable = helpers_1.replaceAll(mutable, "{{scene_id}}", " " + (sceneID++));
    return mutable;
}
