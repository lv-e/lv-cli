"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const helpers_1 = require("../helpers/helpers");
const fs_1 = require("fs");
const path_1 = require("path");
const shelljs_1 = __importDefault(require("shelljs"));
const astyle_1 = __importDefault(require("astyle"));
const encoder_templates_1 = require("../helpers/encoder_templates");
const helpText = `
'encode' will receive a path to the project structure generated by 'scan'
 and encode files by its extension.
 the output will be a .h strip.`;
let vflag = false;
let sceneID = 1;
let outputDir;
const encoders = [
    { extension: ".lvcode", npm_module: "@lv-game-editor/encoder-lvcode", command: "lv-encoder-lvcode" },
];
function encode(input, output, mode) {
    if (mode == "help")
        helpers_1.log(true, helpText);
    else {
        outputDir = output;
        vflag = mode == "verbose" ? true : false;
        helpers_1.log(vflag, "[command] encode");
        helpers_1.log(vflag, "updating node modules...");
        updateModules();
        const jsonString = fs_1.readFileSync(input, "utf8");
        const data = JSON.parse(jsonString);
        data.scenes.forEach(scene => {
            encodeScene(scene);
        });
    }
}
exports.encode = encode;
function encodeScene(scene) {
    helpers_1.log(vflag, "encoding: " + scene.name);
    encodeDir(scene, scene);
    mergeEncoded(scene).then(response => {
        const sceneSourceDir = path_1.join(outputDir, "source");
        let hppPath = path_1.join(sceneSourceDir, scene.name + ".h");
        let cppPath = path_1.join(sceneSourceDir, scene.name + ".c");
        helpers_1.createDirs(hppPath);
        helpers_1.createDirs(cppPath);
        fs_1.writeFileSync(hppPath, response.hpp);
        fs_1.writeFileSync(cppPath, response.cpp);
    });
}
function encodeDir(dir, scene) {
    dir.directories.forEach(dir => encodeDir(dir, scene));
    dir.files.forEach(file => encodeFile(file, scene));
}
function updateModules() {
    encoders.forEach(encoder => {
        if (!shelljs_1.default.which(encoder.command)) {
            helpers_1.log(vflag, "updating encoder under npm module named " + encoder.npm_module);
            shelljs_1.default.exec("npm i -g " + encoder.npm_module);
        }
    });
}
function encodeFile(file, scene) {
    encoders.forEach(encoder => {
        if (encoder.extension == file.extension) {
            helpers_1.log(vflag, "encoding file: " + file.name + " with " + encoder.npm_module);
            const outputFile = path_1.join(outputDir, scene.name, "h-stripes", file.name + ".h-stripe");
            shelljs_1.default.exec(encoder.command + " -i " + file.path + " -o " + outputFile);
        }
    });
}
function mergeEncoded(scene) {
    return __awaiter(this, void 0, void 0, function* () {
        const sceneDir = path_1.join(outputDir, scene.name, "h-stripes");
        helpers_1.log(vflag, "reducing encoded scene files under dir " + sceneDir);
        const files = fs_1.readdirSync(sceneDir);
        let reduced = {
            declarations: "",
            on_awake: "",
            on_enter: "",
            on_frame: "",
            on_exit: ""
        };
        files.forEach(file => {
            const filepath = path_1.join(sceneDir, file);
            const jsonString = fs_1.readFileSync(filepath, "utf8");
            const data = JSON.parse(jsonString);
            reduced.declarations += helpers_1.removeBlankLines("\n" + (data.declarations || ""));
            reduced.on_awake += helpers_1.removeBlankLines("\n" + (data.on_awake || ""));
            reduced.on_enter += helpers_1.removeBlankLines("\n" + (data.on_enter || ""));
            reduced.on_frame += helpers_1.removeBlankLines("\n" + (data.on_frame || ""));
            reduced.on_exit += helpers_1.removeBlankLines("\n" + (data.on_exit || ""));
        });
        function applyReplaces(subject) {
            let mutable = subject;
            mutable = helpers_1.replaceAll(mutable, "{{scene_name}}", scene.name);
            mutable = helpers_1.replaceAll(mutable, "{{uppercased_scene_name}}", scene.name.toUpperCase());
            mutable = helpers_1.replaceAll(mutable, "{{scene_id}}", " " + (sceneID++));
            mutable = helpers_1.replaceAll(mutable, "{{declarations}}", reduced.declarations);
            mutable = helpers_1.replaceAll(mutable, "{{on_awake}}", reduced.on_awake);
            mutable = helpers_1.replaceAll(mutable, "{{on_enter}}", reduced.on_enter);
            mutable = helpers_1.replaceAll(mutable, "{{on_frame}}", reduced.on_frame);
            mutable = helpers_1.replaceAll(mutable, "{{on_exit}}", reduced.on_exit);
            return mutable;
        }
        let sceneCPPFile = yield astyle_1.default.format(applyReplaces(encoder_templates_1.template_cpp));
        let sceneHPPFile = yield astyle_1.default.format(applyReplaces(encoder_templates_1.template_hpp));
        return { hpp: sceneHPPFile, cpp: sceneCPPFile };
    });
}
