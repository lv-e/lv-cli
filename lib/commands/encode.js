"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const helpers_1 = require("../helpers/helpers");
const fs_1 = require("fs");
const path_1 = require("path");
const encoder_templates_1 = require("../helpers/encoder_templates");
const chalk = require("chalk");
const encode_scene_1 = require("./encode_helpers/encode_scene");
const encode_project_1 = require("./encode_helpers/encode_project");
const helpText = `
'encode' will receive a path to the project structure generated by 'scan'
 and encode files by its extension. the output will be a lot of .hstrip files.`;
exports.vflag = false;
function encode(input, output, mode) {
    return __awaiter(this, void 0, void 0, function* () {
        if (mode == "help")
            helpers_1.log(true, helpText);
        else {
            exports.outputDir = output;
            exports.vflag = mode == "verbose" ? true : false;
            helpers_1.log(exports.vflag, chalk.green("[command] ") + chalk.blue("encode"));
            // load project file
            const projectJson = fs_1.readFileSync(input, "utf8");
            const projectData = JSON.parse(projectJson);
            // encode project, this will download the engine library too
            exports.project = encode_project_1.encodeProject(projectData.project_file);
            // encode all scenes, this will generate .hstripes
            let promises = yield projectData.scenes.map((scene) => __awaiter(this, void 0, void 0, function* () { return yield encode_scene_1.encodeScene(scene); }));
            let encodedScenes = yield Promise.all(promises);
            // encode all shared files
            //data.shared.map( dir => encodeSharedDir(dir))
            encodeMainFiles(encodedScenes);
        }
    });
}
exports.encode = encode;
/*

function encodeSharedDir(dir:dirMap){

    log(vflag, chalk.blue("encoding shared folder: ") + chalk.cyan(dir.name))
    dir.files.forEach( file => encodeSharedFile(file))
    dir.directories.forEach( dir =>  encodeSharedDir(dir))

    const sharedSourceDir = join(outputDir, "source")
        
    let hppPath = join(sharedSourceDir, "shared.h")
    let cppPath = join(sharedSourceDir, "shared.c")

    createDirs(hppPath)
    createDirs(cppPath)

}
    
function encodeSharedFile(file:fileMap) {
    encoders.forEach( encoder => {
        if (encoder.extension == file.extension) {
            log(vflag, "encoding shared file: " + file.name + " with " + encoder.npm_module)
            const outputFile = join(outputDir, "shared", "h-stripes", file.name + ".h-stripe")
            shell.exec(encoder.cli_command + " -i " + file.path + " -o " + outputFile)
        }
    })
}


async function mergeEncodedShared() {

    const sharedDir = join(outputDir, "shared", "h-stripes")
    log(vflag, "reducing encoded shared files under dir " + sharedDir)
    const files = readdirSync(sharedDir)

    let reduced:encoded = blankEncoded()
    reduced.include_directive = "#include \"shared.h\""

    files.forEach( file => {

        const filepath = join("shared", file)
        const jsonString = readFileSync(filepath, "utf8")
        const data:encoded = JSON.parse(jsonString)

        reduced.declarations   += removeBlankLines("\n" + (data.declarations || ""))
        reduced.on_awake       += removeBlankLines("\n" + (data.on_awake || ""))
        reduced.on_enter       += removeBlankLines("\n" + (data.on_enter || ""))
        reduced.on_frame       += removeBlankLines("\n" + (data.on_frame || ""))
        reduced.on_exit        += removeBlankLines("\n" + (data.on_exit  || ""))
    })

    function applyReplaces(subject:string) : string {
        let mutable = applySceneReplaces(subject, scene)
        mutable = replaceAll(mutable, "{{declarations}}", reduced.declarations || "")
        mutable = replaceAll(mutable, "{{on_awake}}", reduced.on_awake || "")
        mutable = replaceAll(mutable, "{{on_enter}}", reduced.on_enter || "")
        mutable = replaceAll(mutable, "{{on_frame}}", reduced.on_frame || "")
        mutable = replaceAll(mutable, "{{on_exit}}" , reduced.on_exit  || "")
        return mutable
    }

    let sceneCPPFile = await astyle.format(applyReplaces(template_scene_cpp))
    let sceneHPPFile = await astyle.format(applyReplaces(template_scene_hpp))

    return {hpp: sceneHPPFile, cpp: sceneCPPFile, encodedScene: reduced}
}*/
function encodeMainFiles(encodedScenes) {
    helpers_1.log(exports.vflag, chalk.blue("generating main.c file"));
    let includes = encodedScenes.map(s => s.include_directive).join("\n");
    let mainCode = helpers_1.replaceAll(encoder_templates_1.template_main_c, "{{scene_includes}}", includes);
    let mainFilePath = path_1.join(exports.outputDir, "source", "main.c");
    fs_1.writeFileSync(mainFilePath, mainCode);
    helpers_1.log(exports.vflag, "done! main.c can be found at: " + mainFilePath);
}
