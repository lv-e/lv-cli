import { log, rand_salt, replaceAll, removeBlankLines, createDirs } from "../helpers/helpers";
import { readFileSync, readdir, readdirSync, writeFileSync } from "fs";
import { join } from "path";
import { mode, encoded, encoder, rootFolders, sceneMap, dirMap, fileMap, projectContent } from "../index";
import shell from "shelljs";
import astyle from "astyle";
import { template_scene_cpp, template_scene_hpp, template_scene_include, template_main_c } from "../helpers/encoder_templates";
import chalk = require("chalk");

const helpText = `
'encode' will receive a path to the project structure generated by 'scan'
 and encode files by its extension.
 the output will be a .h strip.`

 let vflag:boolean = false
 let sceneID = 1
 let outputDir:string
 let encoders:encoder[] = []

export async function encode(input:string, output:string, mode:mode) {
    if (mode == "help") log(true, helpText)
    else {

        outputDir = output
        vflag = mode == "verbose" ? true : false
        log(vflag, chalk.green("[command] ") + chalk.blue("encode"))

        const jsonString = readFileSync(input, "utf8")
        const data:rootFolders = JSON.parse(jsonString) 
        
        encodeProject(data.project_file)
        
        let promises = await data.scenes.map( async scene =>  await encodeScene(scene))
        let encodedScenes = await Promise.all(promises)
        
        data.shared.map( dir => encodeSharedDir(dir))
        
        encodeMainFiles(encodedScenes)
    }
} 

function encodeSharedDir(dir:dirMap){
    log(vflag, chalk.blue("encoding shared folder: ") + chalk.cyan(dir.name))
    dir.files.forEach( file => encodeSharedFile(file))
    dir.directories.forEach( dir =>  encodeSharedDir(dir))
}
    
function encodeSharedFile(file:fileMap) {
    encoders.forEach( encoder => {
        if (encoder.extension == file.extension) {
            log(vflag, "encoding shared file: " + file.name + " with " + encoder.npm_module)
            const outputFile = join(outputDir, "shared", "h-stripes", file.name + ".h-stripe")
            shell.exec(encoder.cli_command + " -i " + file.path + " -o " + outputFile)
        }
    })
}

function encodeMainFiles(encodedScenes:encoded[]) {
    log(vflag, chalk.blue("generating main.c file"))
    let includes = encodedScenes.map( s => s.globals ).join("\n")
    let mainCode = replaceAll(template_main_c, "{{scene_includes}}", includes)
    let mainFilePath = join(outputDir, "source", "main.c")
    
    writeFileSync(mainFilePath, mainCode)
    log(vflag, "done! main.c can be found at: " + mainFilePath)
}

function updateModules(){
    encoders.forEach ( encoder => {
        if (!shell.which(encoder.cli_command)){
            log(vflag, "updating encoder under npm module named " + encoder.npm_module)
            shell.exec("npm update -g " + encoder.npm_module)   
        }
    })
}

function encodeProject(file:fileMap) {

    const jsonString = readFileSync(file.path, "utf8")
    const project:projectContent = JSON.parse(jsonString) 
    encoders = project.header.encoders

    log(vflag, "updating node modules...")
    updateModules()

    encoders.forEach( encoder => {
        if (encoder.extension == file.extension) {
            const outputFile = join(outputDir, "h-stripes", file.name + ".h-stripe")
            log(vflag, chalk.blue("encoding project: ") + chalk.cyan(file.name))
            log(vflag, "using " + encoder.npm_module)
            shell.exec(encoder.cli_command + " -i " + file.path + " -o " + outputFile)
        }
    })
}

async function encodeScene(scene:sceneMap) : Promise<encoded> {
    
    log(vflag, chalk.blue("encoding: ") + chalk.cyan(scene.name))
    encodeDir(scene, scene)

    const response = await mergeEncoded(scene)
    const sceneSourceDir = join(outputDir, "source")
        
    let hppPath = join(sceneSourceDir, scene.name + ".h")
    let cppPath = join(sceneSourceDir, scene.name + ".c") 
        
    createDirs(hppPath)
    createDirs(cppPath)

    writeFileSync(hppPath, response.hpp)
    writeFileSync(cppPath, response.cpp)

    return response.encodedScene
}

function encodeDir(dir:dirMap, scene:sceneMap) {
    dir.directories.forEach( dir =>  encodeDir(dir, scene))
    dir.files.forEach( file => encodeFile(file, scene))
}

function encodeFile(file:fileMap, scene:sceneMap) {
    encoders.forEach( encoder => {
        if (encoder.extension == file.extension) {
            log(vflag, "encoding file: " + file.name + " with " + encoder.npm_module)
            const outputFile = join(outputDir, scene.name, "h-stripes", file.name + ".h-stripe")
            shell.exec(encoder.cli_command + " -i " + file.path + " -o " + outputFile)
        }
    })
}

async function mergeEncoded(scene:sceneMap) {

    const sceneDir = join(outputDir, scene.name, "h-stripes")
    log(vflag, "reducing encoded scene files under dir " + sceneDir)
    const files = readdirSync(sceneDir)

    let reduced:encoded = {
        globals: "",
        declarations: "",
        on_awake: "",
        on_enter: "",
        on_frame: "",
        on_exit: ""
    }

    reduced.globals = applySceneReplaces(template_scene_include, scene)

    files.forEach( file => {

        const filepath = join(sceneDir, file)
        const jsonString = readFileSync(filepath, "utf8")
        const data:encoded = JSON.parse(jsonString)

        reduced.declarations   += removeBlankLines("\n" + (data.declarations || ""))
        reduced.on_awake       += removeBlankLines("\n" + (data.on_awake || ""))
        reduced.on_enter       += removeBlankLines("\n" + (data.on_enter || ""))
        reduced.on_frame       += removeBlankLines("\n" + (data.on_frame || ""))
        reduced.on_exit        += removeBlankLines("\n" + (data.on_exit  || ""))
    })

    function applyReplaces(subject:string) : string {
        let mutable = applySceneReplaces(subject, scene)
        mutable = replaceAll(mutable, "{{declarations}}", reduced.declarations || "")
        mutable = replaceAll(mutable, "{{on_awake}}", reduced.on_awake || "")
        mutable = replaceAll(mutable, "{{on_enter}}", reduced.on_enter || "")
        mutable = replaceAll(mutable, "{{on_frame}}", reduced.on_frame || "")
        mutable = replaceAll(mutable, "{{on_exit}}" , reduced.on_exit  || "")
        return mutable
    }

    let sceneCPPFile = await astyle.format(applyReplaces(template_scene_cpp))
    let sceneHPPFile = await astyle.format(applyReplaces(template_scene_hpp))

    return {hpp: sceneHPPFile, cpp: sceneCPPFile, encodedScene: reduced}
}

function applySceneReplaces(subject:string, scene:sceneMap) : string {
    let mutable = subject
    mutable = replaceAll(mutable, "{{scene_name}}", scene.name)
    mutable = replaceAll(mutable, "{{uppercased_scene_name}}", scene.name.toUpperCase())
    mutable = replaceAll(mutable, "{{scene_id}}", " " + (sceneID++))
    return mutable
}